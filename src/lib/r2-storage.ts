/**
 * R2 Storage Operations
 *
 * Provides functions for interacting with Cloudflare R2 for video storage.
 * Uses R2 bucket binding for direct operations and generates presigned URLs for client uploads.
 */

import { R2_PATHS, type VideoQuality } from '@/types/encoding.types';

// ============================================================================
// Types
// ============================================================================

export interface R2Config {
  bucket: R2Bucket;
  publicUrl?: string; // CDN URL for public access
}

export interface PresignedUrlOptions {
  expiresIn?: number; // seconds, default 3600 (1 hour)
  contentType?: string;
  contentLength?: number;
}

export interface UploadMetadata {
  videoId: string;
  userId: string;
  filename: string;
  contentType: string;
  contentLength: number;
}

// ============================================================================
// Presigned URL Generation
// ============================================================================

/**
 * Generates a presigned PUT URL for uploading a file directly to R2.
 * This uses the R2 bucket's createMultipartUpload or direct PUT with signed headers.
 *
 * Note: Cloudflare R2 doesn't support traditional S3 presigned URLs directly.
 * For client uploads, we use a worker endpoint that proxies the upload.
 * This function returns the internal path; the actual upload URL is generated by the API route.
 */
export function generateUploadPath(
  videoId: string,
  filename: string
): string {
  return R2_PATHS.raw(videoId, filename);
}

/**
 * Generates a public CDN URL for accessing a file.
 */
export function generatePublicUrl(
  config: R2Config,
  path: string
): string {
  if (!config.publicUrl) {
    throw new Error('R2 public URL is not configured');
  }
  return `${config.publicUrl}/${path}`;
}

/**
 * Generates CDN URLs for encoded video variants.
 */
export function generateVariantUrls(
  config: R2Config,
  videoId: string,
  qualities: VideoQuality[]
): Record<VideoQuality, string> {
  const urls: Partial<Record<VideoQuality, string>> = {};

  for (const quality of qualities) {
    const path = R2_PATHS.encoded(videoId, quality);
    urls[quality] = generatePublicUrl(config, path);
  }

  return urls as Record<VideoQuality, string>;
}

/**
 * Generates a CDN URL for the video thumbnail.
 */
export function generateThumbnailUrl(
  config: R2Config,
  videoId: string
): string {
  const path = R2_PATHS.thumbnail(videoId);
  return generatePublicUrl(config, path);
}

// ============================================================================
// Direct R2 Operations
// ============================================================================

/**
 * Checks if an object exists in R2.
 */
export async function headObject(
  config: R2Config,
  path: string
): Promise<R2Object | null> {
  return config.bucket.head(path);
}

/**
 * Checks if a raw video has been uploaded.
 */
export async function checkRawVideoExists(
  config: R2Config,
  videoId: string,
  filename: string
): Promise<boolean> {
  const path = R2_PATHS.raw(videoId, filename);
  const obj = await headObject(config, path);
  return obj !== null;
}

/**
 * Gets the object metadata and size.
 */
export async function getObjectMetadata(
  config: R2Config,
  path: string
): Promise<{ size: number; etag: string; httpMetadata?: R2HTTPMetadata } | null> {
  const obj = await config.bucket.head(path);
  if (!obj) return null;

  return {
    size: obj.size,
    etag: obj.etag,
    httpMetadata: obj.httpMetadata,
  };
}

/**
 * Deletes an object from R2.
 */
export async function deleteObject(
  config: R2Config,
  path: string
): Promise<void> {
  await config.bucket.delete(path);
}

/**
 * Deletes multiple objects from R2.
 */
export async function deleteObjects(
  config: R2Config,
  paths: string[]
): Promise<void> {
  // R2 supports batch delete
  await config.bucket.delete(paths);
}

/**
 * Deletes all objects associated with a video.
 * This includes raw upload, encoded variants, and thumbnail.
 */
export async function deleteVideoObjects(
  config: R2Config,
  videoId: string,
  filename: string,
  qualities: VideoQuality[] = ['1080p', '720p', '480p']
): Promise<{ deleted: string[]; errors: string[] }> {
  const paths: string[] = [
    R2_PATHS.raw(videoId, filename),
    R2_PATHS.thumbnail(videoId),
    ...qualities.map((q) => R2_PATHS.encoded(videoId, q)),
  ];

  const deleted: string[] = [];
  const errors: string[] = [];

  for (const path of paths) {
    try {
      await deleteObject(config, path);
      deleted.push(path);
    } catch (error) {
      // Object might not exist, which is fine
      errors.push(path);
    }
  }

  return { deleted, errors };
}

/**
 * Lists objects in R2 with a prefix.
 */
export async function listObjects(
  config: R2Config,
  prefix: string,
  options?: {
    limit?: number;
    cursor?: string;
  }
): Promise<{
  objects: R2Object[];
  truncated: boolean;
  cursor?: string;
}> {
  const result = await config.bucket.list({
    prefix,
    limit: options?.limit,
    cursor: options?.cursor,
  });

  return {
    objects: result.objects,
    truncated: result.truncated,
    cursor: result.truncated ? result.cursor : undefined,
  };
}

/**
 * Reads an object from R2.
 */
export async function getObject(
  config: R2Config,
  path: string
): Promise<R2ObjectBody | null> {
  return config.bucket.get(path);
}

/**
 * Writes an object to R2.
 */
export async function putObject(
  config: R2Config,
  path: string,
  body: ReadableStream | ArrayBuffer | string,
  options?: {
    httpMetadata?: R2HTTPMetadata;
    customMetadata?: Record<string, string>;
  }
): Promise<R2Object> {
  return config.bucket.put(path, body, {
    httpMetadata: options?.httpMetadata,
    customMetadata: options?.customMetadata,
  });
}

// ============================================================================
// Helper to create config from env
// ============================================================================

export function createR2Config(env: {
  FILES: R2Bucket;
  R2_PUBLIC_URL?: string;
}): R2Config {
  return {
    bucket: env.FILES,
    publicUrl: env.R2_PUBLIC_URL,
  };
}
